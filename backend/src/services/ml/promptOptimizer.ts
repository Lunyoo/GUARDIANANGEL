import { universalBandits } from '../bot/universalBandits.js'

// üß† Interface para an√°lise de performance do prompt
interface PromptAnalysis {
  currentPrompt: string
  conversionRate: number
  responseTime: number
  customerSatisfaction: number
  commonIssues: string[]
  suggestedImprovements: string[]
}

// üéØ Interface para sugest√£o de otimiza√ß√£o
interface PromptOptimization {
  id: string
  type: 'pricing' | 'messaging' | 'cities' | 'strategy'
  currentValue: string
  suggestedValue: string
  reasoning: string
  expectedImprovement: number
  confidence: number
  testGroup?: string
  createdAt: string
  status: 'pending' | 'approved' | 'rejected' | 'testing'
  approvedBy?: string
  appliedAt?: string
}

// üìä Sistema de otimiza√ß√£o de prompts com ML
export class PromptOptimizer {
  private optimizations = new Map<string, PromptOptimization>()
  private conversationHistory = new Map<string, any[]>()
  
  // üìà Analisar performance atual do prompt
  analyzePromptPerformance(productId: string, timeFrame: number = 24): PromptAnalysis {
    try {
      // Obter dados do Universal Bandits
      const stats = (universalBandits as any).getStatsByCategory?.('messaging') || []
      const pricingStats = (universalBandits as any).getStatsByCategory?.('pricing') || []
      
      // Calcular m√©tricas
      const totalInteractions = stats.reduce((sum: number, stat: any) => sum + (stat.trials || 0), 0)
      const totalConversions = stats.reduce((sum: number, stat: any) => sum + (stat.successes || 0), 0)
      const avgConversion = totalInteractions > 0 ? totalConversions / totalInteractions : 0
      
      // Identificar problemas comuns
      const commonIssues = this.identifyCommonIssues(stats)
      
      // Gerar sugest√µes baseadas em ML
      const suggestions = this.generateMLSuggestions(stats, pricingStats)
      
      return {
        currentPrompt: 'Prompt din√¢mico baseado em produto e campanha',
        conversionRate: avgConversion,
        responseTime: 2.5,
        customerSatisfaction: 0.85,
        commonIssues,
        suggestedImprovements: suggestions
      }
    } catch (error) {
      console.error('‚ùå Erro ao analisar performance do prompt:', error)
      return {
        currentPrompt: 'An√°lise indispon√≠vel',
        conversionRate: 0,
        responseTime: 0,
        customerSatisfaction: 0,
        commonIssues: [],
        suggestedImprovements: []
      }
    }
  }
  
  // üéØ Identificar problemas comuns nas conversas
  private identifyCommonIssues(stats: any[]): string[] {
    const issues: string[] = []
    
    // Analisar baixa convers√£o
    const lowConversionArms = stats.filter(stat => stat.conversionRate < 0.1)
    if (lowConversionArms.length > 0) {
      issues.push('Taxa de convers√£o baixa em algumas abordagens')
    }
    
    // Analisar abandono
    const highAbandonArms = stats.filter(stat => stat.abandonRate > 0.3)
    if (highAbandonArms.length > 0) {
      issues.push('Alto √≠ndice de abandono na conversa')
    }
    
    // Analisar d√∫vidas sobre pre√ßo
    const priceIssues = stats.filter(stat => stat.variant?.includes('pre√ßo') || stat.variant?.includes('caro'))
    if (priceIssues.length > 0) {
      issues.push('Muitas obje√ß√µes relacionadas ao pre√ßo')
    }
    
    // Analisar problemas com entrega
    const deliveryIssues = stats.filter(stat => stat.variant?.includes('entrega') || stat.variant?.includes('COD'))
    if (deliveryIssues.length > 0) {
      issues.push('D√∫vidas frequentes sobre entrega e COD')
    }
    
    return issues
  }
  
  // üß† Gerar sugest√µes de melhoria baseadas em ML
  private generateMLSuggestions(messagingStats: any[], pricingStats: any[]): string[] {
    const suggestions: string[] = []
    
    // Analisar melhores performers
    const topMessaging = messagingStats.sort((a, b) => b.conversionRate - a.conversionRate)[0]
    const topPricing = pricingStats.sort((a, b) => b.conversionRate - a.conversionRate)[0]
    
    if (topMessaging && topMessaging.conversionRate > 0.15) {
      suggestions.push(`Expandir uso da abordagem "${topMessaging.variant}" (${(topMessaging.conversionRate * 100).toFixed(1)}% convers√£o)`)
    }
    
    if (topPricing && topPricing.conversionRate > 0.12) {
      suggestions.push(`Otimizar estrat√©gia de pre√ßo "${topPricing.variant}" (melhor performance)`)
    }
    
    // Sugest√µes baseadas em padr√µes
    suggestions.push('Personalizar mensagens por hor√°rio do dia')
    suggestions.push('Ajustar abordagem baseada na origem da campanha')
    suggestions.push('Otimizar resposta para d√∫vidas sobre COD')
    
    return suggestions
  }
  
  // üéØ Criar otimiza√ß√£o para aprova√ß√£o
  createOptimization(type: PromptOptimization['type'], current: string, suggested: string, reasoning: string): string {
    const optimization: PromptOptimization = {
      id: `opt-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,
      type,
      currentValue: current,
      suggestedValue: suggested,
      reasoning,
      expectedImprovement: this.calculateExpectedImprovement(type),
      confidence: this.calculateConfidence(type),
      createdAt: new Date().toISOString(),
      status: 'pending'
    }
    
    this.optimizations.set(optimization.id, optimization)
    
    console.log(`üéØ Nova otimiza√ß√£o criada: ${optimization.id} (${type})`)
    return optimization.id
  }
  
  // üìä Calcular melhoria esperada
  private calculateExpectedImprovement(type: string): number {
    const improvements = {
      'pricing': 0.15,      // 15% melhoria esperada
      'messaging': 0.12,    // 12% melhoria esperada  
      'cities': 0.08,       // 8% melhoria esperada
      'strategy': 0.20      // 20% melhoria esperada
    }
    return improvements[type as keyof typeof improvements] || 0.10
  }
  
  // üéØ Calcular confian√ßa na sugest√£o
  private calculateConfidence(type: string): number {
    const confidence = {
      'pricing': 0.85,      // 85% confian√ßa
      'messaging': 0.75,    // 75% confian√ßa
      'cities': 0.90,       // 90% confian√ßa
      'strategy': 0.70      // 70% confian√ßa
    }
    return confidence[type as keyof typeof confidence] || 0.75
  }
  
  // ‚úÖ Aprovar otimiza√ß√£o
  approveOptimization(optimizationId: string, approvedBy: string): boolean {
    const optimization = this.optimizations.get(optimizationId)
    if (!optimization || optimization.status !== 'pending') {
      return false
    }
    
    optimization.status = 'approved'
    optimization.approvedBy = approvedBy
    optimization.appliedAt = new Date().toISOString()
    
    this.optimizations.set(optimizationId, optimization)
    
    // Aplicar a otimiza√ß√£o ao sistema
    this.applyOptimization(optimization)
    
    console.log(`‚úÖ Otimiza√ß√£o aprovada: ${optimizationId} por ${approvedBy}`)
    return true
  }
  
  // ‚ùå Rejeitar otimiza√ß√£o
  rejectOptimization(optimizationId: string, rejectedBy: string): boolean {
    const optimization = this.optimizations.get(optimizationId)
    if (!optimization || optimization.status !== 'pending') {
      return false
    }
    
    optimization.status = 'rejected'
    optimization.approvedBy = rejectedBy
    
    this.optimizations.set(optimizationId, optimization)
    
    console.log(`‚ùå Otimiza√ß√£o rejeitada: ${optimizationId} por ${rejectedBy}`)
    return true
  }
  
  // üöÄ Aplicar otimiza√ß√£o aprovada
  private applyOptimization(optimization: PromptOptimization) {
    try {
      switch (optimization.type) {
        case 'pricing':
          this.applyPricingOptimization(optimization)
          break
        case 'messaging':
          this.applyMessagingOptimization(optimization)
          break
        case 'cities':
          this.applyCitiesOptimization(optimization)
          break
        case 'strategy':
          this.applyStrategyOptimization(optimization)
          break
      }
      
      console.log(`üöÄ Otimiza√ß√£o aplicada: ${optimization.type} - ${optimization.id}`)
    } catch (error) {
      console.error('‚ùå Erro ao aplicar otimiza√ß√£o:', error)
    }
  }
  
  // üí∞ Aplicar otimiza√ß√£o de pre√ßo
  private applyPricingOptimization(optimization: PromptOptimization) {
    // Atualizar Universal Bandits com nova estrat√©gia de pre√ßo
    const context = {
      type: 'pricing_optimization',
      strategy: optimization.suggestedValue,
      confidence: optimization.confidence
    }
    
    // Registrar nova arm no Universal Bandits
    ;(universalBandits as any).recordResult?.('pricing', optimization.suggestedValue, true, context)
  }
  
  // üí¨ Aplicar otimiza√ß√£o de mensagem
  private applyMessagingOptimization(optimization: PromptOptimization) {
    // Atualizar estrat√©gia de mensagem no Universal Bandits
    const context = {
      type: 'messaging_optimization',
      newApproach: optimization.suggestedValue,
      confidence: optimization.confidence
    }
    
    ;(universalBandits as any).recordResult?.('messaging', optimization.suggestedValue, true, context)
  }
  
  // üèôÔ∏è Aplicar otimiza√ß√£o de cidades
  private applyCitiesOptimization(optimization: PromptOptimization) {
    // Atualizar estrat√©gia de COD no Universal Bandits
    const context = {
      type: 'cities_optimization',
      newCities: optimization.suggestedValue,
      confidence: optimization.confidence
    }
    
    ;(universalBandits as any).recordResult?.('delivery', optimization.suggestedValue, true, context)
  }
  
  // üéØ Aplicar otimiza√ß√£o de estrat√©gia
  private applyStrategyOptimization(optimization: PromptOptimization) {
    // Atualizar estrat√©gia geral no Universal Bandits
    const context = {
      type: 'strategy_optimization', 
      newStrategy: optimization.suggestedValue,
      confidence: optimization.confidence
    }
    
    ;(universalBandits as any).recordResult?.('strategy', optimization.suggestedValue, true, context)
  }
  
  // üìä Obter todas as otimiza√ß√µes pendentes
  getPendingOptimizations(): PromptOptimization[] {
    return Array.from(this.optimizations.values())
      .filter(opt => opt.status === 'pending')
      .sort((a, b) => new Date(b.createdAt).getTime() - new Date(a.createdAt).getTime())
  }
  
  // üìà Obter hist√≥rico de otimiza√ß√µes
  getOptimizationHistory(): PromptOptimization[] {
    return Array.from(this.optimizations.values())
      .sort((a, b) => new Date(b.createdAt).getTime() - new Date(a.createdAt).getTime())
  }
  
  // üéØ Obter otimiza√ß√£o por ID
  getOptimization(id: string): PromptOptimization | undefined {
    return this.optimizations.get(id)
  }
  
  // ü§ñ Gerar otimiza√ß√µes autom√°ticas baseadas em ML
  generateAutomaticOptimizations(): string[] {
    const generated: string[] = []
    
    // Analisar performance atual
    const analysis = this.analyzePromptPerformance('default')
    
    // Gerar otimiza√ß√µes baseadas nos problemas identificados
    if (analysis.conversionRate < 0.12) {
      const id = this.createOptimization(
        'messaging',
        'Abordagem atual padr√£o',
        'Abordagem mais direta focada em benef√≠cios',
        'Taxa de convers√£o baixa detectada pelo ML'
      )
      generated.push(id)
    }
    
    if (analysis.commonIssues.includes('Muitas obje√ß√µes relacionadas ao pre√ßo')) {
      const id = this.createOptimization(
        'pricing',
        'Estrat√©gia de pre√ßo atual',
        'Estrat√©gia com mais foco em valor e parcelamento',
        'ML detectou resist√™ncia ao pre√ßo nas conversas'
      )
      generated.push(id)
    }
    
    if (analysis.commonIssues.includes('D√∫vidas frequentes sobre entrega e COD')) {
      const id = this.createOptimization(
        'cities',
        'Explica√ß√£o COD atual',
        'Explica√ß√£o mais clara sobre COD e entrega r√°pida',
        'ML identificou confus√£o sobre processo de entrega'
      )
      generated.push(id)
    }
    
    console.log(`ü§ñ ${generated.length} otimiza√ß√µes autom√°ticas geradas`)
    return generated
  }
}

export const promptOptimizer = new PromptOptimizer()
